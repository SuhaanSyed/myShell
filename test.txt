int whitespaceCount(char *in, int len);
int stitch(char *in, char **out);
void trim(char *str);


int redirection_check(char *command)
{
    char *out = strstr(command, ">");
    char *in = strstr(command, "<");
    char *append = strstr(command, ">>");

    if (append != NULL)
    {
        // Appending output redirection
        return 4;
    }
    else if ((out != NULL) && (in != NULL))
    {
        // both input and output redirection
        return 3;
    }
    else if (out != NULL)
    {
        // output redirection only
        return 2;
    }
    else if (in != NULL)
    {
        // input redirection only
        return 1;
    }
    else
    {
        return -1;
    }
}
void trim(char *str)
{

        int i;
    int begin = 0;

    int end = strlen(str) - 1;

    while (isspace((unsigned char) str[begin]))
        begin++;

    while ((end >= begin) && isspace((unsigned char) str[end]))
        end--;

    // Shift all characters back to the start of the string array.
    for (i = begin; i <= end; i++)
        str[i - begin] = str[i];

    str[i - begin] = '\0'; // Null terminate string.
}
// counts number of whitespaces in a given input string
int whitespaceCount(char *in, int len)
{
    int i = 0;
    int count = 0;
    for (i = 0; i < len; i++)
    {
        if (in[i] == ' ')
        {
            count++;
        }
    }
    return count;
}

// takes an input array and returns a char ** that points to
// the array of strings delimited by a space
int stitch(char *in, char **out)
{
    int i = 1;
    char *temp, cpy[100];

    sprintf(cpy, "%s", in);

    temp = strtok(in, " ");
    sprintf(out[0], "%s", temp);

    while ((temp = strtok(NULL, " ")) != NULL)
    {
        sprintf(out[i], "%s", temp);
        i++;
    }
    out[i] = NULL;
    return i;
}

// implements redirection
int redirection(char *input, int state)
{

    char cpy[1000], path[1000], command[1000], filename[1000], **args, *temp;
    int spacecount, i = 0, fd;

    sprintf(cpy, "%s", input);

    temp = strtok(cpy, " ");
    sprintf(path, "%s", temp);

    sprintf(cpy, "%s", input);

    if (state == 1)
    {
        temp = strtok(cpy, "<");
        sprintf(command, "%s", temp);
        command[strlen(command) - 1] = '\0';
        temp[strlen(temp) - 1] = '\0';

        temp = strtok(NULL, "\0");
        sprintf(filename, "%s", temp);
        trim(filename);

        spacecount = whitespaceCount(command, strlen(command));

        args = calloc((spacecount) + 2, sizeof(char *));
        for (i = 0; i < spacecount + 1; i++)
        {
            args[i] = calloc(strlen(command) + 10, sizeof(char));
        }

        i = stitch(command, args);

        if ((fd = open(filename, O_RDONLY, 0644)) < 0)
        {
            perror("open error");
            return -1;
        }

        dup2(fd, 0);
        close(fd);

        execvp(path, (char *const *)args);
        perror("execvp error");
        _exit(EXIT_FAILURE);
    }
    else if (state == 2)
    {
        temp = strtok(cpy, ">");
        sprintf(command, "%s", temp);
        command[strlen(command) - 1] = '\0';
        temp[strlen(temp) - 1] = '\0';

        temp = strtok(NULL, "\0");
        sprintf(filename, "%s", temp);
        trim(filename);

        spacecount = whitespaceCount(command, strlen(command));

        args = calloc((spacecount) + 2, sizeof(char *));

        for (i = 0; i < spacecount + 1; i++)
        {
            args[i] = calloc(strlen(command) + 10, sizeof(char));
        }

        i = stitch(command, args);

        if ((fd = open(filename, O_CREAT | O_WRONLY | O_TRUNC, 0644)) < 0)
        {
            perror("open error");
            return -1;
        }

        dup2(fd, 1);
        close(fd);

        execvp(path, (char *const *)args);
        perror("execvp error");
        _exit(EXIT_FAILURE);
    }
    else if (state == 3)
    {
        char filename2[1000];
        int fd2;

        temp = strtok(cpy, "<");
        sprintf(command, "%s", temp);
        command[strlen(command) - 1] = '\0';
        temp[strlen(temp) - 1] = '\0';

        temp = strtok(NULL, ">");
        sprintf(filename, "%s", temp);
        filename[strlen(filename) - 1] = '\0';
        temp[strlen(temp) - 1] = '\0';
        trim(filename);

        temp = strtok(NULL, "\0");
        sprintf(filename2, "%s", temp);
        trim(filename2);

        spacecount = whitespaceCount(command, strlen(command));

        args = calloc((spacecount) + 2, sizeof(char *));
        for (i = 0; i < spacecount + 1; i++)
        {
            args[i] = calloc(strlen(command) + 10, sizeof(char));
        }

        i = stitch(command, args);

        if ((fd = open(filename, O_RDONLY, 0644)) < 0)
        {
            perror("open error");
            return -1;
        }

        if ((fd2 = open(filename2, O_CREAT | O_WRONLY | O_TRUNC, 0644)) < 0)
        {
            perror("open error");
            return -1;
        }

        dup2(fd, 0);
        close(fd);

        dup2(fd2, 1);
        close(fd2);

        execvp(path, (char *const *)args);
        perror("execvp error");
        _exit(EXIT_FAILURE);
    }
    else if (state == 4)
    {
        temp = strtok(cpy, ">>");
        sprintf(command, "%s", temp);
        command[strlen(command) - 1] = '\0'; // Remove the space before the ">>"
        temp[strlen(temp) - 1] = '\0';

        temp = strtok(NULL, "\0");
        sprintf(filename, "%s", temp);
        trim(filename); // Assuming trim() is a function that removes leading and trailing whitespaces

        spacecount = whitespaceCount(command, strlen(command));

        args = calloc((spacecount) + 2, sizeof(char *));
        for (i = 0; i < spacecount + 1; i++)
        {
            args[i] = calloc(strlen(command) + 10, sizeof(char));
        }

        i = stitch(command, args);

        // Open the file for appending. If it doesn't exist, create it.
        if ((fd = open(filename, O_CREAT | O_WRONLY | O_APPEND, 0644)) < 0)
        {
            perror("open error");
            return -1;
        }

        dup2(fd, 1); // Redirect stdout to the file
        close(fd);

        execvp(path, (char *const *)args);
        perror("execvp error");
        _exit(EXIT_FAILURE);
    }
    return 1;
}